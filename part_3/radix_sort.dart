extension RadixSort on List<int> {
  // Вспомогательный метод для поиска максимального элемента в массиве
  // Нужен для определения количества разрядов в самом большом числе
  int _getMax(List<int> arr) {
    int aMax = -double.maxFinite.toInt();

    for (int val in arr) {
      if (aMax < val) {
        aMax = val;
      }
    }
    return aMax;
  }

  // Основной метод поразрядной сортировки
  List<int> radixSort(List<int> arr) {
    // Проверяем, что массив не пустой
    if (arr.isEmpty) {
      throw ArgumentError('Array is empty');
    }

    // Переменная для отслеживания текущего разряда
    // (единицы, десятки, сотни и т.д.)
    // Начинаем с младшего разряда (единицы)
    int digPlace = 1;

    // Вспомогательный массив для хранения результата
    // сортировки на каждом этапе
    List<int> result = List<int>.filled(arr.length, 0);

    // Находим максимальное число для определения количества разрядов
    int maxNumber = _getMax(arr);

    // Сортируем элементы массива до тех пор,
    // пока есть разряды для обработки
    while ((maxNumber ~/ digPlace) > 0) {
      // Массив для подсчета частоты каждой цифры (0-9)
      List<int> count = List<int>.filled(10, 0);

      // Подсчитываем количество каждой цифры в текущем разряде
      for (int val in arr) {
        // Извлекаем цифру текущего разряда
        count[(val ~/ digPlace) % 10]++;
      }

      // Преобразуем массив подсчета в "накопительные суммы"
      //
      // Например, если count = [2, 1, 3, 0, 1, 0, 0, 0, 0, 0]
      // это значит, что цифра 0 встречается 2 раза,
      // цифра 1 - 1 раз, цифра 2 - 3 раза и т.д.
      //
      // После преобразования получим: [2, 3, 6, 6, 7, 7, 7, 7, 7, 7]
      // Это означает:
      // - элементы с цифрой 0 должны занимать позиции 0-1
      //   (всего 2 позиции)
      // - элементы с цифрой 1 должны занимать позиции 2-2
      //   (всего 1 позиция)
      // - элементы с цифрой 2 должны занимать позиции 3-5
      //   (всего 3 позиции)
      // - и так далее...
      //
      // Каждое число в массиве показывает, на какой позиции
      // заканчивается группа элементов с данной цифрой
      for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
      }

      // Размещаем элементы в отсортированном порядке,
      // проходя массив справа налево
      for (int i = arr.length - 1; i >= 0; i--) {
        // Получаем цифру текущего разряда
        int digit = (arr[i] ~/ digPlace) % 10;

        // Размещаем элемент в правильную позицию
        // в результирующем массиве
        result[count[digit] - 1] = arr[i];

        // Уменьшаем счетчик для данной цифры
        count[digit]--;
      }

      // Копируем результат обратно в исходный массив
      for (int i = 0; i < arr.length; i++) {
        arr[i] = result[i];
      }

      // Переходим к следующему разряду (умножаем на 10)
      digPlace *= 10;
    }

    return arr;
  }
}

void main() {
  List<int> arr = [1, 2, 6, 0, 362, 214, 22, 54, 109, 5, 3];
  print('Array before sort: $arr');
  List<int> sortedArray = arr.radixSort(arr);
  print('Array after sorting: $sortedArray');
}
